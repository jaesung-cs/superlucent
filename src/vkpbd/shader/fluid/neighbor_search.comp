#version 450

layout (local_size_x = 256) in;

#include "particle.glsl"
#include "fluid_simulation_params.glsl"
#include "neighbors.glsl"
#include "uniform_grid.glsl"

void main() 
{
	const uint i0 = gl_GlobalInvocationID.x;
	if (i0 >= params.num_particles)
    return;

  float r0 = params.radius;
  
	vec3 p0 = out_particles[i0].position.xyz;

  // Neighbor search between particles in uniform grid
  ivec3 cell_index = CellIndex(p0);
  uint hash_index = GridHash(cell_index);

  const int max_num_neighbors = 50;
  int num_neighbors = 0;
  uint neighbor_ids[max_num_neighbors];

  uint num_particles_in_grid = 0;

  int pointer = grid.hash_table_head[hash_index];
  while (pointer >= 0 && num_neighbors < max_num_neighbors && num_neighbors < params.max_num_neighbors)
  {
    uint i1 = grid.object_grid_pairs[pointer].object_id;
    
    if (i0 < i1)
    {
      vec3 p1 = out_particles[i1].position.xyz;
      vec3 pd = p1 - p0;
    
      float r1 = params.radius;

      if (dot(pd, pd) <= (r0 + r1) * (r0 + r1))
      {
        bool found = false;
        for (int i = 0; i < num_neighbors; i++)
        {
          if (neighbor_ids[i] == i1)
          {
            found = true;
            break;
          }
        }

        if (!found)
        {
          neighbor_ids[num_neighbors] = i1;
          num_neighbors++;

          AddNeighbor(i0, i1);
        }
      }
    }

    pointer = grid.object_grid_pairs[pointer].next;

    num_particles_in_grid++;
  }

  // out_particles[i0].color.rgb = vec3((hash_index % 256) / 255.f, ((hash_index / 256) % 256) / 255.f, ((hash_index / 65536) % 256) / 255.f);
  out_particles[i0].color.rgb = vec3(NeighborCount(i0) / 5.f);
}
