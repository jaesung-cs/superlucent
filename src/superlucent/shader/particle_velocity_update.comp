#version 450

layout (local_size_x = 256) in;

#include "particle/particle.h"
#include "particle/simulation_params.h"

vec3 computeRestitutionUpdate(vec3 normal, vec4 velocity, vec4 prev_velocity, float resilience)
{
  float vn = dot(velocity.xyz, normal);
  float vntilde = dot(prev_velocity.xyz, normal);

  return normal * (-vn + -resilience * vntilde);
}

void main() 
{
	const int index = int(gl_GlobalInvocationID);
	if (index >= params.num_particles)
    return;
    
  const float radius = particles[index].properties.x;
  const float mass = particles[index].properties.y;

  vec4 prev_velocity = particles[index].velocity;
  vec4 velocity = (particles[index].position - particles[index].prev_position) / params.dt;
  
  // Solve velocities
  const float resilience = 0.9f;

  vec4 solved_velocity = velocity;
  /*
  if (collision.x != 0.f)
  {
    const vec3 normal = vec3(collision.x, 0.f, 0.f);
    vec3 dv = computeRestitutionUpdate(normal, velocity, prev_velocity, resilience);
    solved_velocity.xyz += dv;
  }

  if (collision.y != 0.f)
  {
    const vec3 normal = vec3(0.f, collision.y, 0.f);
    vec3 dv = computeRestitutionUpdate(normal, velocity, prev_velocity, resilience);
    solved_velocity.xyz += dv;
  }

  if (collision.z != 0.f)
  {
    const vec3 normal = vec3(0.f, 0.f, collision.z);
    vec3 dv = computeRestitutionUpdate(normal, velocity, prev_velocity, resilience);
    solved_velocity.xyz += dv;
  }
  */

  particles[index].velocity = solved_velocity;
}
