#version 450

layout (local_size_x = 256) in;

#include "particle/particle.h"
#include "particle/simulation_params.h"
#include "particle/collision_pairs.h"
#include "particle/solver.h"

void main() 
{
	const uint constraint_id = gl_GlobalInvocationID.x;
	if (constraint_id >= Rows())
    return;

  uvec2 is = collisions[constraint_id].ids.xy;
  float m0_inv = 1.f / particles[is[0]].properties.x;

  vec3 x0;
  for (int i = 0; i < 3; i++)
  {
    uvec2 x0_index = XIndex(is[0] * 3 + i);
    x0[i] = solver.matrix[x0_index.x][x0_index.y];
  }

  vec3 r0 = collisions[constraint_id].r[0].xyz;
  vec3 n = collisions[constraint_id].n.xyz;

  float c = dot(x0 + r0, n);
  vec3 Jc0 = n;
  
  vec3 x1 = vec3(0.f);
  vec3 Jc1 = vec3(0.f);
  float m1_inv = 0.f;
  if (is[1] >= 0)
  {
    m1_inv = 1.f / particles[is[1]].properties.x;

    vec3 x1;
    for (int i = 0; i < 3; i++)
    {
      uvec2 x1_index = XIndex(is[1] * 3 + i);
      x1[i] = solver.matrix[x1_index.x][x1_index.y];
    }

    vec3 r1 = collisions[constraint_id].r[1].xyz;
    vec3 n = collisions[constraint_id].n.xyz;

    c -= dot(x1 + r1, n);
    Jc1 = -n;
  }

  float alpha_tilde = params.alpha / params.dt / params.dt;

  uvec2 lambda_index = LambdaIndex(constraint_id);
  float lambda = solver.matrix[lambda_index.x][lambda_index.y];

  float numerator = -c - alpha_tilde * lambda;
  float denominator = m0_inv * dot(Jc0, x0) - m1_inv * dot(Jc1, x1) + alpha_tilde;

  uvec2 delta_lambda_index = DeltaLambdaIndex(constraint_id);
  solver.matrix[delta_lambda_index.x][delta_lambda_index.y] = numerator / denominator;
}
