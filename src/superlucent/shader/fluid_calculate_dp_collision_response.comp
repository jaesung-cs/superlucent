#version 450

layout (local_size_x = 256) in;

#include "fluid/particle.glsl"
#include "fluid/simulation_params.glsl"
#include "fluid/neighbors.glsl"
#include "fluid/kernel.glsl"
#include "fluid/solver.glsl"

void main()
{
  uint i = gl_GlobalInvocationID.x;
  if (i >= params.num_particles)
    return;
    
  const float h = params.h;
  const float rho0 = params.rest_density;

  const vec3 pi = particles[i].position.xyz;
  const float lambda_i = solver[i].lambda;

  vec3 dp = vec3(0.f);

  int pointer = neighbors_heads[i];
  while (pointer >= 0)
  {
    int j = neighbors[pointer].index;

    const float lambda_j = solver[j].lambda;

    const vec3 pj = particles[j].position.xyz;
    const float r = distance(pi, pj);

    vec3 n;
    if (r > 0.f)
      n = (pi - pj) / (r + params.epsilon);
    else
      n = vec3(0.f, 0.f, 1.f);

    dp += 1.f / rho0 * (lambda_i + lambda_j) * DKernelSpiky(r, h) * n;

    pointer = neighbors[pointer].next;
  }

  vec3 pnext = pi + dp;
  
  // TODO: collision response
  const vec2 wall_distance = vec2(3.f + params.wall_offset, 1.5f);

  if (pnext.x < -wall_distance.x)
    pnext.x = -wall_distance.x;
    
  if (pnext.x > wall_distance.x)
    pnext.x = wall_distance.x;
    
  if (pnext.y < -wall_distance.y)
    pnext.y = -wall_distance.y;
    
  if (pnext.y > wall_distance.y)
    pnext.y = wall_distance.y;

  if (pnext.z < 0.f)
    pnext.z = 0.f;

  solver[i].dp = pnext - pi;
}
