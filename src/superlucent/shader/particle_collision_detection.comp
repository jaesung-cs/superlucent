#version 450

layout (local_size_x = 256) in;

#include "particle/particle.h"
#include "particle/simulation_params.h"
#include "particle/collision_pairs.h"
#include "particle/uniform_grid.h"

void main() 
{
	const uint i0 = gl_GlobalInvocationID.x;
	if (i0 >= params.num_particles)
    return;

  float r0 = particles[i0].properties.x;
  
	vec3 p0 = particles[i0].position.xyz;

  // Collision between particles in uniform grid
  ivec3 cell_index = CellIndex(p0);
  uint hash_index = GridHash(cell_index);

  const int num_max_contacts = 120;
  int num_contacts = 0;
  uint contact_ids[num_max_contacts];

  int pointer = grid_hash_table.head[hash_index];
  while (pointer >= 0)
  {
    uint i1 = grid.object_grid_pairs[pointer].object_id;
    
    if (i0 < i1)
    {
      vec3 p1 = particles[i1].position.xyz;
      vec3 pd = p1 - p0;
    
      float r1 = particles[i1].properties.x;

      if (dot(pd, pd) <= (r0 + r1) * (r0 + r1))
      {
        bool found = false;
        for (int i = 0; i < num_contacts; i++)
        {
          if (contact_ids[i] == i1)
          {
            found = true;
            break;
          }
        }

        if (!found)
        {
          contact_ids[num_contacts] = i1;
          num_contacts++;
          
          const uint collision_index = atomicAdd(num_collisions, 1);

          vec3 n = -normalize(pd);
          collisions[collision_index].ids[0] = int(i0);
          collisions[collision_index].ids[1] = int(i1);

          collisions[collision_index].r[0] = vec4(-n * r0, 0.f);
          collisions[collision_index].r[1] = vec4(n * r1, 0.f);
          collisions[collision_index].n = vec4(n, 0.f);
        }
      }
    }

    pointer = grid.object_grid_pairs[pointer].next;
  }
  
  /*
  for (uint i1 = i0 + 1; i1 < params.num_particles; i1++)
  {
    vec3 p1 = particles[i1].position.xyz;
    vec3 pd = p1 - p0;

    float r1 = particles[i1].properties.x;

    if (dot(pd, pd) <= (r0 + r1) * (r0 + r1))
    {
      const uint collision_index = atomicAdd(num_collisions, 1);

      vec3 n = -normalize(pd);
      collisions[collision_index].ids[0] = int(i0);
      collisions[collision_index].ids[1] = int(i1);

      collisions[collision_index].r[0] = vec4(-n * r0, 0.f);
      collisions[collision_index].r[1] = vec4(n * r1, 0.f);
      collisions[collision_index].n = vec4(n, 0.f);
    }
  }
  */
  
  // Collision against floor and virtual walls
  const float wall_distance = 2.f;

  if (p0.x - r0 < -wall_distance)
  {
    const uint collision_index = atomicAdd(num_collisions, 1);

    collisions[collision_index].ids[0] = int(i0);
    collisions[collision_index].ids[1] = -1;

    collisions[collision_index].r[0] = vec4(-r0, 0.f, 0.f, 0.f);
    collisions[collision_index].r[1] = vec4(-wall_distance, p0.yz, 0.f);
    collisions[collision_index].n = vec4(1.f, 0.f, 0.f, 0.f);
  }

  if (p0.x + r0 > wall_distance)
  {
    const uint collision_index = atomicAdd(num_collisions, 1);

    collisions[collision_index].ids[0] = int(i0);
    collisions[collision_index].ids[1] = -1;

    collisions[collision_index].r[0] = vec4(r0, 0.f, 0.f, 0.f);
    collisions[collision_index].r[1] = vec4(wall_distance, p0.yz, 0.f);
    collisions[collision_index].n = vec4(-1.f, 0.f, 0.f, 0.f);
  }

  if (p0.y - r0 < -wall_distance)
  {
    const uint collision_index = atomicAdd(num_collisions, 1);

    collisions[collision_index].ids[0] = int(i0);
    collisions[collision_index].ids[1] = -1;

    collisions[collision_index].r[0] = vec4(0.f, -r0, 0.f, 0.f);
    collisions[collision_index].r[1] = vec4(p0.x, -wall_distance, p0.z, 0.f);
    collisions[collision_index].n = vec4(0.f, 1.f, 0.f, 0.f);
  }

  if (p0.y + r0 > wall_distance)
  {
    const uint collision_index = atomicAdd(num_collisions, 1);

    collisions[collision_index].ids[0] = int(i0);
    collisions[collision_index].ids[1] = -1;

    collisions[collision_index].r[0] = vec4(0.f, r0, 0.f, 0.f);
    collisions[collision_index].r[1] = vec4(p0.x, wall_distance, p0.z, 0.f);
    collisions[collision_index].n = vec4(0.f, -1.f, 0.f, 0.f);
  }

  if (p0.z - r0 < 0.f)
  {
    const uint collision_index = atomicAdd(num_collisions, 1);

    collisions[collision_index].ids[0] = int(i0);
    collisions[collision_index].ids[1] = -1;

    collisions[collision_index].r[0] = vec4(0.f, 0.f, -r0, 0.f);
    collisions[collision_index].r[1] = vec4(p0.xy, 0.f, 0.f);
    collisions[collision_index].n = vec4(0.f, 0.f, 1.f, 0.f);
  }
}
