#version 450

layout (local_size_x = 256) in;

#include "particle.glsl"
#include "simulation_params.glsl"
#include "neighbors.glsl"
#include "../uniform_grid/uniform_grid.glsl"

void main()
{
  uint i = gl_GlobalInvocationID.x;
  if (i >= params.num_particles)
    return;

  vec3 pi = particles[i].position.xyz;

  const float h = params.h;

  // Find neighbors in uniform grid
  ivec3 cell_index = CellIndex(pi);
  uint hash_index = GridHash(cell_index);

  int num_particle_neighbors = 0;

  int pointer = grid_hash_table.head[hash_index];
  while (pointer >= 0)
  {
    uint j = grid.object_grid_pairs[pointer].object_id;
    
    if (i != j)
    {
      vec3 pj = particles[j].position.xyz;
      vec3 r = pi - pj;
    
      if (dot(r, r) <= h * h)
      {
        const uint neighbor_index = atomicAdd(num_neighbors, 1);
        if (neighbor_index < params.max_num_neighbors)
        {
          neighbors[neighbor_index].index = int(j);

          int next = atomicExchange(neighbors_heads[i], int(neighbor_index));
          neighbors[neighbor_index].next = next;

          num_particle_neighbors++;
        }
      }
    }

    pointer = grid.object_grid_pairs[pointer].next;
  }
  
  // DEBUG particle color
  // particles[i].color.rgb = vec3(0.f, 0.f, float(num_particle_neighbors - 5));
  // particles[i].color.rgb = vec3(0.f, 0.f, float(hash_index) / num_hash_buckets);
}
